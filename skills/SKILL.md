---
name: nuwa-build
description: Expert capabilities for building Python extensions using Nim with nuwa-build
---

# Nuwa-Build Skills

You are an expert in using `nuwa-build`, a tool for building Python extensions with Nim. When a user asks to create, build, or test a Python extension using Nim, follow these rules.

## Prerequisites & Validation

Before working with nuwa-build, verify the environment is ready:

1. **Nim Compiler**: Run `nim --version` (requires Nim to be installed and in PATH)
2. **Nimble**: Run `nimble --version` (Nim's package manager, comes with Nim)
3. **Nuwa**: Run `nuwa --help` (should be installed via `pip install nuwa-build`)

If any are missing, guide the user to install them:

- Nim: https://nim-lang.org/install.html
- Nuwa: `pip install nuwa-build`
- nimpy: `nimble install nimpy` (or add to `nimble-deps` in config)

## Project Structure

A standard Nuwa project has this flat layout:

```text
project_root/
├── pyproject.toml           # Configuration ([tool.nuwa])
├── nim/                     # Nim source files
│   ├── my_lib.nim           # Entry point (often {module_name}_lib.nim)
│   └── helpers.nim          # Other Nim modules
├── my_package/              # Python package wrapper
│   ├── __init__.py          # Imports the compiled extension
│   └── my_lib.so            # Compiled artifact (generated by nuwa)
└── tests/                   # Pytest files
```

## Capabilities & Commands

### Creating a New Project

If the user asks to start a new project, run:

```bash
nuwa new <project_name>
```

- This creates the directory structure, `pyproject.toml`, and initial Nim/Python files.
- If the user specifies a custom Python package name different from the folder, use `--name <name>`.
- **Important**: Project names with hyphens need `--name` to specify a valid Python identifier.

### Initializing an Existing Project

If the user wants to add Nuwa to an existing project:

```bash
nuwa init [path]
```

- Initializes Nuwa in an existing project directory (defaults to current directory)
- Adds `[build-system]` and `[tool.nuwa]` to existing `pyproject.toml` (or creates one if missing)
- Creates `nim/` directory with scaffolding if it doesn't exist
- Updates `.gitignore` with build artifacts if needed
- Non-destructive: won't overwrite existing files
- Use this when you have an existing Python project and want to add Nim extensions

### Building & Developing

**Do not** use `python setup.py build`, use nuwa commands instead:

- **Debug Build:** Run `nuwa develop`. This compiles the Nim code into the Python package folder.
- **Release Build:** Run `nuwa develop --release`. Use this for production-ready artifacts.
- **Build Wheel:** Run `nuwa build` to create a distributable wheel in `dist/`. This is the recommended way to build wheels for distribution.
- **Watch Mode:** Run `nuwa watch` to auto-recompile on file changes.
- **Watch + Test:** Run `nuwa watch --run-tests` to run pytest after every compile.

### Running Code

- **After Building:** You can run Python scripts directly (e.g., `python example.py`) without installing the package, because the `.so` file is placed inside the Python package directory.
- **Testing:** Run `pytest`. The flat layout allows pytest to discover the compiled module automatically.
- **No Installation Needed**: The flat layout means you don't need `pip install -e .` for development.

### Maintenance

- **Cleaning:** Run `nuwa clean` to remove build artifacts.
- **Deep Clean:** Run `nuwa clean --deps` to remove installed Nimble dependencies.

## Configuration (`pyproject.toml`)

If you need to configure the build, look for the `[tool.nuwa]` section in `pyproject.toml`.

**Common Settings:**

```toml
[tool.nuwa]
nim-source = "nim"              # Source directory (default: "nim")
module-name = "my_package"      # Python import name
lib-name = "my_package_lib"     # Internal library name (default: {module_name}_lib)
entry-point = "my_lib.nim"      # Main Nim file (auto-discovered if not set)
output-location = "auto"        # "auto" (flat), "src", or custom path
nim-flags = []                  # Additional compiler flags
nimble-deps = ["nimpy"]         # Auto-installed dependencies

# Build profiles (predefined compiler flag sets)
[tool.nuwa.profiles.dev]
nim-flags = ["-d:debug", "--debugger:native", "--linenos:on"]

[tool.nuwa.profiles.release]
nim-flags = ["-d:release", "--opt:speed", "--stacktrace:off"]

[tool.nuwa.profiles.bench]
nim-flags = ["-d:release", "--opt:speed", "--stacktrace:on"]
```

**Configuration Options:**

- `nim-source`: Directory containing Nim source files
- `module-name`: Python package name (derived from project name if not set)
- `lib-name`: Name of the compiled extension (default: `{module_name}_lib`)
- `entry-point`: Main entry point file (auto-discovered if not specified)
- `output-location`: Where to place compiled extension
- `nim-flags`: Additional Nim compiler flags (e.g., `["-d:danger", "--opt:size"]`)
- `nimble-deps`: Nimble packages to auto-install before build
- `profiles`: Predefined build profiles with preset compiler flags

**Using Build Profiles:**

```bash
# Use a profile when building
nuwa develop --profile dev
nuwa build --profile release
nuwa watch --profile bench
```

**Flag precedence:**
1. Base `nim-flags` from `[tool.nuwa]`
2. Profile flags (appended)
3. CLI `--nim-flag` arguments (applied last)

## Entry Point Discovery

Nuwa auto-discovers the main Nim file in this priority order:

1. Explicit `entry-point` in `[tool.nuwa]`
2. `{lib_name}.nim` (e.g., `my_package_lib.nim`)
3. `lib.nim` (fallback convention)
4. Single `.nim` file (if only one exists in nim-source directory)
5. **Error** if multiple files found and no clear entry point

**Best Practice**: Name your entry point `{module_name}_lib.nim` for clarity and auto-discovery.

## Output Location

By default (`output-location = "auto"`), compiled extensions go to:

```
{module_name}/{lib_name}.so   # Linux/Mac
{module_name}/{lib_name}.pyd  # Windows
```

This flat layout allows immediate testing without installation. The compiled extension is named `{lib_name}` (e.g., `my_package_lib.so`) to avoid conflicts with the Python package name.

## Writing Nim for Python

### Basic Export Pattern

- **Import nuwa_sdk:** All Nim files should `import nuwa_sdk` for automatic type stub generation.
- **Exporting:** Use `{.nuwa_export.}` pragma to expose Nim procedures to Python (this automatically generates type stubs).

```nim
import nuwa_sdk

proc add(a: int, b: int): int {.nuwa_export.} =
  return a + b

proc greet(name: string): string {.nuwa_export.} =
  return "Hello, " & name & "!"
```

### Python Wrapper

In `__init__.py`, import everything from the compiled lib:

```python
# In my_package/__init__.py
from .my_package_lib import *

__version__ = "0.1.0"

# Optionally add Python wrappers or additional functionality
```

## Multi-File Nim Projects

Use `include` (not `import`) for shared library builds:

**nim/my_package_lib.nim:**

```nim
import nuwa_sdk
include helpers  # Include helpers.nim from same directory

proc greet(name: string): string {.nuwa_export.} =
  return make_greeting(name)
```

**nim/helpers.nim:**

```nim
proc make_greeting(name: string): string =
  return "Hello, " & name & "!"
```

**Why `include`?** It includes code at compile time, creating a single compilation unit. `import` creates separate module namespaces which don't work well for shared libraries. All files are compiled into a single `.so`/`.pyd` file.

## Package Data (Config Files, Assets, etc.)

Nuwa automatically includes all non-Python files from your package directory when building wheels. This includes config files, data files, templates, models, and other assets.

### Automatic Inclusion (Default)

By default, all files in your package directory are included in the wheel except:

- Python cache (`__pycache__`, `*.pyc`, `*.pyo`)
- Compiled extensions (`.so`, `.pyd`, `.dll` - added separately)
- Version control (`.git`, `.hg`, `.svn`)
- Build artifacts (`dist/`, `build/`, `*.egg-info`)
- Development caches (`.pytest_cache`, `.mypy_cache`, `.ruff_cache`)
- IDE files (`.vscode`, `.idea`, `.DS_Store`)
- Test directories (`tests/`, `test/`)

**Example:**
```
my_package/
├── __init__.py       # ✅ Included
├── config.json       # ✅ Included (config file)
├── data.csv          # ✅ Included (data file)
├── model.bin         # ✅ Included (binary asset)
└── templates/
    └── page.html     # ✅ Included (template)
```

### Fine-Grained Control with MANIFEST.in

For precise control over package data, create a `MANIFEST.in` file in your project root:

```
include package/config.json
recursive-include package/templates *.html *.css *.js
global-include *.md
exclude package/dev_config.yaml
recursive-exclude package/tests *.py
```

**Supported commands:**

- `include pattern ...` - Include files matching patterns
- `exclude pattern ...` - Exclude files matching patterns
- `recursive-include dir pattern ...` - Include files in directory matching patterns
- `recursive-exclude dir pattern ...` - Exclude files in directory matching patterns
- `global-include pattern ...` - Include files anywhere matching patterns
- `global-exclude pattern ...` - Exclude files anywhere matching patterns

**Common patterns:**

```bash
# Include specific config file
include package/production.json

# Exclude development configs
exclude package/*-dev.yaml
exclude package/config.local.*

# Include all templates
recursive-include package/templates *

# Include but exclude test data
recursive-include package/data *.csv
recursive-exclude package/data test-*.csv

# Include documentation
global-include *.md
global-include LICENSE
```

**When helping users:**
- Most projects don't need MANIFEST.in - the default behavior works well
- Recommend MANIFEST.in only when users need to exclude specific files or have complex packaging requirements
- This matches standard Python packaging behavior (setuptools, flit, etc.)

## Build Backend (PEP 517)

Nuwa can be used as a build backend in `pyproject.toml`:

```toml
[build-system]
requires = ["nuwa-build"]
build-backend = "nuwa_build"

[project]
name = "my-package"
version = "0.1.0"
```

This enables:

- `pip install .` - Build and install the package
- `python -m build` - Create wheel and source distribution
- `pip install -e .` - Editable installs (though `nuwa develop` is preferred for development)
- `pip install . --no-build-isolation` - Build a wheel

## Common Errors & Solutions

### "Nim compiler not found"

**Cause**: Nim is not installed or not in PATH.
**Solution**: Install Nim from https://nim-lang.org/install.html and ensure it's in your PATH.

### "ModuleNotFoundError: No module named 'my_package'"

**Cause**: Extension hasn't been compiled yet.
**Solution**: Run `nuwa develop` to generate the `.so`/`.pyd` extension.

### "cannot open file: nimpy"

**Cause**: nimpy library not installed.
**Solution**: Either add to config (auto-installs):

```toml
[tool.nuwa]
nimble-deps = ["nimpy"]
```

Or manually: `nimble install nimpy`

### "Multiple .nim files found in nim/"

**Cause**: Nuwa can't determine which file is the entry point.
**Solution**: Add to `pyproject.toml`:

```toml
[tool.nuwa]
entry-point = "my_entry_file.nim"
```

Or name your entry point `{module_name}_lib.nim` for auto-discovery.

### "Module name '...' is not a valid Python identifier"

**Cause**: Project name has hyphens or invalid characters.
**Solution**: Use `nuwa new my-project --name my_valid_name` to specify a valid Python identifier.

### "nimble package manager not found"

**Cause**: Nimble is not installed or not in PATH.
**Solution**: Nimble comes with Nim. Reinstall Nim from https://nim-lang.org/install.html.

## AI Agent Guidelines

When helping users with nuwa-build:

1. **Always check prerequisites first** - Run `nim --version` and `nuwa --help` before attempting builds
2. **Use `nuwa develop` for development** - Not `pip install` or `setup.py build`
3. **Use `nuwa build` for distribution** - Creates wheels in `dist/` directory, recommended over `pip wheel` or `python -m build`
4. **Prefer watch mode for iterative development** - `nuwa watch --run-tests` provides fast feedback
5. **Check for existing config** - Read `[tool.nuwa]` in `pyproject.toml` before suggesting changes
6. **Validate module names** - Python identifiers only (letters, numbers, underscores; cannot start with number)
7. **Auto-install dependencies** - Add to `nimble-deps` rather than manual `nimble install` commands
8. **Understand the flat layout** - No `pip install -e .` needed; compiled extension goes directly into package
9. **Use `include` for multi-file projects** - Not `import`, when building shared libraries
10. **Name entry points consistently** - Use `{module_name}_lib.nim` for auto-discovery
11. **Test after building** - Run `pytest` directly after `nuwa develop` completes
12. **Use build profiles for consistency** - Recommend profiles over ad-hoc `--nim-flag` usage when appropriate
13. **Check for existing profiles** - Review `[tool.nuwa.profiles]` before suggesting new compiler flag combinations

## Advanced Usage

### Shell Completion

Nuwa supports shell completion for bash, zsh, and fish. This requires the optional `shtab` dependency.

**Installation:**

```bash
# Install shtab
pip install shtab

# Generate and install completions
nuwa --print-completion bash > ~/.local/share/bash-completion/completions/nuwa
nuwa --print-completion zsh > ~/.zfunc/_nuwa
nuwa --print-completion fish > ~/.config/fish/completions/nuwa.fish
```

**For zsh users**, add to `~/.zshrc`:

```bash
fpath=(~/.zfunc $fpath)
autoload -U compinit && compinit
```

**When helping users set up their environment:**
- Mention shell completion as an optional productivity booster
- It's not required for basic usage but improves CLI experience
- Completion works for all commands, flags, and suggests files/directories

### Custom Compiler Flags

Add Nim compiler flags for optimization or debugging:

```toml
[tool.nuwa]
nim-flags = [
    "-d:danger",      # Maximum optimization (removes runtime checks)
    "--opt:size",     # Optimize for size
    "-d:release",     # Release mode
]
```

### Build Profiles (Preferred Approach)

For reusable flag sets, use build profiles instead of base `nim-flags`:

```toml
[tool.nuwa.profiles.dev]
nim-flags = ["-d:debug", "--debugger:native", "--linenos:on"]

[tool.nuwa.profiles.release]
nim-flags = ["-d:release", "--opt:speed", "--stacktrace:off"]

[tool.nuwa.profiles.bench]
nim-flags = ["-d:release", "--opt:speed", "--stacktrace:on"]
```

Usage: `nuwa develop --profile dev`

### Custom Output Location

For src-layout projects:

```toml
[tool.nuwa]
output-location = "src"  # Places extension in src/{module_name}/
```

### Version-Specific Dependencies

```toml
[tool.nuwa]
nimble-deps = [
    "nimpy",
    "cligen >= 1.0.0",
    "arraymancer@#head",
]
```

## Workflow Examples

### Creating and Testing a New Project

```bash
# Create project
nuwa new my_project
cd my_project

# Build debug version
nuwa develop

# Run example
python example.py

# Run tests
pytest

# Start watch mode for development
nuwa watch --run-tests
```

### Initializing an Existing Project

```bash
# Navigate to existing project
cd existing_project

# Initialize Nuwa (adds config, creates nim/ directory)
nuwa init

# Start developing
nuwa develop
```

### Building for Distribution

```bash
# Build a wheel for distribution
nuwa build

# Build with custom flags
nuwa build --nim-flag="-d:release" --nim-flag="--opt:speed"

# Build with profile (recommended)
nuwa build --profile release

# Install and test locally
pip install dist/*.whl

# Upload to PyPI
pip install twine
twine upload dist/*.whl
```

**Note**: The `nuwa build` command is the recommended way to build wheels. It creates wheels in the `dist/` directory following standard Python packaging conventions. For source distributions or advanced use cases, you can still use `python -m build`.
